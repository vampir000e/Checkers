//PVS
    double score = 0;
    double best = 0;

    if(depth <= 0)
    {
        score = eval(board,side);
        return score;
    }

    vector<StoneAndChessPosition> way;//生成可下位置
    way.clear();
    way = getCompleteWay(board,side);
    way = pvspx(way,side);//PVS排序

    makeMove(way[0]);
    best = -PVS(depth-1,-side,-beta,-alpha);
    //cout<<"!!!!!!!!!!!"<<endl;

   unmakeMove(way[0]);
    bestMove = way[0];

    if(depth == MAX_DEPTH)
    {
        bestMove = way[0];
    }

    int n=0;
    n = way.size();

    for(int i=1;i<n;i++)
    {
        if(best<beta)
        {
            if(best>alpha)
            {
                alpha = best;
            }
            makeMove(way[i]);
            score = -PVS(depth-1,-side,-alpha-1,-alpha);

            if(score>alpha&&score<beta)
            {
                best = -PVS(depth-1,-side,-beta,-score);
                if(depth == MAX_DEPTH)
                {
                    bestMove = way[i];
                }
            }
            else if(score >best)
            {
                best = score;
                if(depth == MAX_DEPTH)
                {
                    bestMove = way[i];
                }
            }
            unmakeMove(way[i]);
        }
    }

    return best;



Function PVS( node，depth，alpha，beta，gamer)
 if ( depth = 0)
 return valuation( gamer) 
else if ( gamer = max_gamer) 
for each child of node
   if child is first child value = PVS( child，depth － 1，alpha， beta，min_gamer) else value = PVS( child，depth － 1，alpha， alpha + 1，min_gamer) if alpha ＜ value ＜ beta value = PVS( child，depth － 1，value， beta，min_gamer) if ( value ＞ alpha) alpha = value if ( alpha ＞ = beta) break return alpha else for each child of node if child is first child value = PVS( child，depth － 1，alpha， beta，max_gamer) else value = PVS( child，depth － 1，beta － 1，beta，max_gamer) if alpha ＜ value ＜ beta value = PVS( child，depth － 1，alpha， value，max_gamer) if ( value ＜ beta) beta = value if ( alpha ＞ = beta) break return alpha